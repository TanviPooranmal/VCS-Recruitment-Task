package main

import (
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/dchest/uniuri"
	"golang.org/x/crypto/openpgp"
	"golang.org/x/crypto/openpgp/armor"
)

// Configuration holds the configuration parameters for the backup tool
type Configuration struct {
	RootDir      string // Root directory for the backup
	LoggerFormat string // Format of the logger file in the backup directory
}

var (
	// Default configuration values
	defaultConfig = Configuration{
		RootDir:      "./backup",
		LoggerFormat: "2006-01-02T15:04:05",
	}
)

func main() {
	// Define command-line flags
	backupCmd := flag.NewFlagSet("backup", flag.ExitOnError)
	shareCmd := flag.NewFlagSet("share", flag.ExitOnError)
	configCmd := flag.NewFlagSet("config", flag.ExitOnError)

	// Backup flags
	backupSrcDir := backupCmd.String("src", "", "Source directory to backup")
	encryptFlag := backupCmd.Bool("encrypt", false, "Encrypt files during backup")
	shareFlag := backupCmd.Bool("share", false, "Share the backup directory")
	recursiveFlag := backupCmd.Bool("recursive", false, "Recursively encrypt files")
	selectiveEncrypt := backupCmd.String("selective", "", "Selectively encrypt files (comma-separated)")
	backupCmd.Parse(os.Args[2:])

	// Share flags
	shareDir := shareCmd.String("dir", "", "Directory to share")
	shareFiles := shareCmd.String("files", "", "Files to send (comma-separated)")
	sharePreviousVersions := shareCmd.Bool("prev-versions", false, "Share previous backup versions")
	shareCmd.Parse(os.Args[2:])

	// Configuration flags
	configRootDir := configCmd.String("root-dir", defaultConfig.RootDir, "Root directory for the backup")
	configLoggerFormat := configCmd.String("logger-format", defaultConfig.LoggerFormat, "Format of the logger file")
	configCmd.Parse(os.Args[2:])

	// Load configuration
	config := Configuration{
		RootDir:      *configRootDir,
		LoggerFormat: *configLoggerFormat,
	}

	// Execute appropriate subcommand
	switch os.Args[1] {
	case "backup":
		err := backup(*backupSrcDir, *encryptFlag, *recursiveFlag, *selectiveEncrypt, *shareFlag, config)
		if err != nil {
			log.Fatal(err)
		}
	case "share":
		err := share(*shareDir, *shareFiles, *sharePreviousVersions, config)
		if err != nil {
			log.Fatal(err)
		}
	case "config":
		fmt.Println("Root Directory:", config.RootDir)
		fmt.Println("Logger Format:", config.LoggerFormat)
	default:
		fmt.Println("Invalid command. Please use 'backup', 'share', or 'config'")
	}
}

func backup(srcDir string, encrypt bool, recursive bool, selectiveEncrypt string, share bool, config Configuration) error {
	// Create backup directory if not exists
	backupDir := filepath.Join(config.RootDir, time.Now().Format(config.LoggerFormat))
	if _, err := os.Stat(backupDir); os.IsNotExist(err) {
		err := os.MkdirAll(backupDir, 0755)
		if err != nil {
			return err
		}
	}

	// Log file
	logFile, err := os.Create(filepath.Join(backupDir, "backup.log"))
	if err != nil {
		return err
	}
	defer logFile.Close()

	logger := log.New(io.MultiWriter(os.Stdout, logFile), "", log.LstdFlags)

	logger.Printf("Backup started at %s", time.Now().Format(time.RFC3339))

	// Copy files
	err = filepath.Walk(srcDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}
		relPath, err := filepath.Rel(srcDir, path)
		if err != nil {
			return err
		}
		destPath := filepath.Join(backupDir, relPath)

		// Skip if it's the source directory
		if srcDir == path {
			return nil
		}

		// Encrypt file if specified
		if encrypt {
			if recursive || (selectiveEncrypt != "" && strings.Contains(selectiveEncrypt, relPath)) {
				// Encrypt file
				err = encryptFile(path, destPath)
				if err != nil {
					return err
				}
				logger.Printf("Encrypted file: %s", relPath)
				return nil
			}
		}

		if info.IsDir() {
			err = os.MkdirAll(destPath, info.Mode())
			if err != nil {
				return err
			}
			logger.Printf("Created directory: %s", relPath)
			return nil
		}

		if !info.Mode().IsRegular() {
			logger.Printf("Skipping non-regular file: %s", relPath)
			return nil
		}

		// Copy regular files
		srcFile, err := os.Open(path)
		if err != nil {
			return err
		}
		defer srcFile.Close()

		destFile, err := os.Create(destPath)
		if err != nil {
			return err
		}
		defer destFile.Close()

		_, err = io.Copy(destFile, srcFile)
		if err != nil {
			return err
		}
		logger.Printf("Copied file: %s", relPath)
		return nil
	})

	if err != nil {
		return err
	}

	logger.Printf("Backup completed at %s", time.Now().Format(time.RFC3339))
	return nil
}

func encryptFile(srcPath, destPath string) error {
	srcFile, err := os.Open(srcPath)
	if err != nil {
		return err
	}
	defer srcFile.Close()

	destFile, err := os.Create(destPath)
	if err != nil {
		return err
	}
	defer destFile.Close()

	// Create new OpenPGP entity for recipient
	entity, err := openpgp.NewEntity("Backup", "", "", nil)
	if err != nil {
		return err
	}

	w, err := armor.Encode(destFile, openpgp.FileHints{IsBinary: true}, nil)
	if err != nil {
		return err
	}
	defer w.Close()

	// Encrypt file
	plaintext, err := openpgp.Encrypt(w, []*openpgp.Entity{entity}, nil, nil, nil)
	if err != nil {
		return err
	}

	_, err = io.Copy(plaintext, srcFile)
	if err != nil {
		return err
	}

	err = plaintext.Close()
	if err != nil {
		return err
	}

	return nil
}

func share(shareDir, files string, prevVersions bool, config Configuration) error {
	// Sharing logic goes here
	return nil
}
